/**
 * <h4>Description</h4>
 * <p>
 * This module offers capabalities for running an Atomic Swap Contract. Atomic swaps,
 * offer a way to swap cryptocurrencies peer-to-peer directly
 * without the requirement for a third party, such as an exchange.</p>
 * <p>
 * This Marlowe Contract has 2 participants (A `Seller` and a `Buyer`) that will atomically exchange
 * some tokens A for some tokens B. Sellers can retract their offer and every state of this contract
 * are timeboxed. Sellers are known at the contract creation (fixed Address) and Buyers are unknown
 * (This showcases a feature of marlowe that is called Open Roles.).
 * There are 3 main stages :
 * - The Offer : The Sellers deposit their tokens.
 * - The Ask : The Buyers deposit their tokens
 * - The Swap Confirmation : an extra Notify input is added after the swap to avoid double-satisfaction attack (see link attached).
 *                          (Any third participant could perform this action)
 * </p>
 * @see
 *  - https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe-runtime/doc/open-roles.md
 *
 * @example
 *
 * ```ts
 * import { AtomicSwap } from "@marlowe.io/language-examples";
 * import { datetoTimeout, tokenValue } from "@marlowe.io/language-core-v1";
 * import { addDays } from "date-fns";
 *
 * const aSellerAddressBech32 = "addr_test1qqe342swyfn75mp2anj45f8ythjyxg6m7pu0pznptl6f2d84kwuzrh8c83gzhrq5zcw7ytmqc863z5rhhwst3w4x87eq0td9ja"
 *
 * const tokenA = token("1f7a58a1aa1e6b047a42109ade331ce26c9c2cce027d043ff264fb1f","A")
 * const tokenB = token("1f7a58a1aa1e6b047a42109ade331ce26c9c2cce027d043ff264fb1f","B")
 *
 * const scheme: AtomicSwap.Scheme = {
 *      offer: {
 *        seller: { address: aSellerAddressBech32 },
 *        deadline: datetoTimeout(addDays(Date.now(), 1)),
 *        asset: tokenValue(10n)(tokenA),
 *      },
 *      ask: {
 *        buyer: { role_token: "buyer" },
 *        deadline: datetoTimeout(addDays(Date.now(), 1)),
 *        asset: tokenValue(10n)(tokenB),
 *      },
 *      swapConfirmation: {
 *        deadline: datetoTimeout(addDays(Date.now(), 1)),
 *      },
 *    };
 *
 * const myAtomicSwap = AtomicSwap.mkContract(scheme)
 *
 * // .. Then you can use the runtime to pilot this contract over Cardano using `getState` ...
 * ```
 *
 * @packageDocumentation
 */

import {
  Address,
  Contract,
  IChoice,
  IDeposit,
  INotify,
  Input,
  MarloweState,
  Role,
  Timeout,
  TokenValue,
  close,
  datetoTimeout,
} from "@marlowe.io/language-core-v1";
import * as G from "@marlowe.io/language-core-v1/guards";
import { SingleInputTx } from "@marlowe.io/language-core-v1/semantics";

/**
 * Atomic Swap Scheme, canonical information to define the contract.
 * The contract can be generated by its scheme.
 */
export type Scheme = {
  offer: {
    seller: Address;
    asset: TokenValue;
    deadline: Timeout;
  };
  ask: {
    buyer: Role;
    deadline: Timeout;
    asset: TokenValue;
  };
  // Extra phase for security reasons (a Notify input is added after the swap to avoid double-satisfaction attack
  // and therefore a timeout is associated with it)
  swapConfirmation: {
    deadline: Timeout;
  };
};

/* #region State */
export type State = ActiveState | Closed;

export type ActiveState = WaitingSellerOffer | NoSellerOfferInTime | WaitingForAnswer | WaitingForSwapConfirmation;

export type WaitingSellerOffer = {
  typeName: "WaitingSellerOffer";
};

export const waitingSellerOffer: WaitingSellerOffer = {
  typeName: "WaitingSellerOffer",
};

export type NoSellerOfferInTime = {
  typeName: "NoSellerOfferInTime";
};
export const noSellerOfferInTime: NoSellerOfferInTime = {
  typeName: "NoSellerOfferInTime",
};

export type WaitingForAnswer = {
  typeName: "WaitingForAnswer";
};

export const waitingForAnswer: WaitingForAnswer = {
  typeName: "WaitingForAnswer",
};

/*
 * <p>
 *  The buyer has provided a deposit, the swapped is theoritically done, but to avoid double-satisfaction attack an
 *  extra Notify input is added after the swap. This Notify can be done by anybody.</p>
 * <p>
 * Marlowe's prevention of double-satisfaction attacks requires that no external payments be made from a Marlowe contract
 * if another Plutus script runs in the transaction. Thus, if an open-role is distributed in a transaction, the transaction
 * cannot do Pay to parties or implicit payments upon Close. Typically, the distribution of an open-role in a Marlowe contract
 * will be followed by a Notify TrueObs case so that further execution of the contract does not proceed in that transactions.
 * External payments can be made in subsequent transactions.
 * </p>
 */
export type WaitingForSwapConfirmation = {
  typeName: "WaitingForSwapConfirmation";
};

export const waitingForSwapConfirmation: WaitingForSwapConfirmation = {
  typeName: "WaitingForSwapConfirmation",
};

/**
 * when the contract is closed.
 */
export type Closed = {
  typeName: "Closed";
  reason: CloseReason;
};

/* #region Action  */
/**
 * Action List available for the contract lifecycle.
 */
export type Action =
  /* When Contract Created (timed out > NoOfferProvisionnedOnTime) */
  | ProvisionOffer // > OfferProvisionned
  /* When NoOfferProvisionnedOnTime (timed out > no timeout (need to be reduced to be closed))*/
  | RetrieveMinimumLovelaceAdded // > closed
  /* When OfferProvisionned (timed out > NotConfirmedOnTime) */
  | Retract // > closed
  | Swap // > Swapped
  /* When Swapped  (timed out > NotConfirmedOnTime) */
  | ConfirmSwap; // > closed

export type ActionParticipant = "buyer" | "seller" | "anybody";

export type RetrieveMinimumLovelaceAdded = {
  typeName: "RetrieveMinimumLovelaceAdded";
  owner: ActionParticipant;
};

export type ProvisionOffer = {
  typeName: "ProvisionOffer";
  owner: ActionParticipant;
  input: IDeposit;
};

export type Swap = {
  typeName: "Swap";
  owner: ActionParticipant;
  input: IDeposit;
};

export type ConfirmSwap = {
  typeName: "ConfirmSwap";
  owner: ActionParticipant;
  input: INotify;
};

export type Retract = {
  typeName: "Retract";
  owner: ActionParticipant;
  input: IChoice;
};

/* #endregion */

/* #region Close Reason */
export type CloseReason =
  | NoOfferProvisionnedOnTime
  | SellerRetracted
  | NotAnsweredOnTime
  | Swapped
  | SwappedButNotNotifiedOnTime;

export type NoOfferProvisionnedOnTime = {
  typeName: "NoOfferProvisionnedOnTime";
};
export type SellerRetracted = { typeName: "SellerRetracted" };
export type NotAnsweredOnTime = { typeName: "NotAnsweredOnTime" };
export type SwappedButNotNotifiedOnTime = {
  typeName: "SwappedButNotNotifiedOnTime";
};
export type Swapped = { typeName: "Swapped" };

/* #endregion */

export class UnexpectedActiveSwapContractState extends Error {
  public type = "UnexpectedActiveSwapContractState" as const;
  public scheme: Scheme;
  public state: MarloweState;
  public inputHistory: SingleInputTx[];
  constructor(scheme: Scheme, inputHistory: SingleInputTx[], state: MarloweState) {
    super("Swap Contract / Unexpected Active State");
    this.scheme = scheme;
    this.state = state;
    this.inputHistory = inputHistory;
  }
}

export class UnexpectedClosedSwapContractState extends Error {
  public type = "UnexpectedClosedSwapContractState" as const;
  public scheme: Scheme;
  public inputHistory: SingleInputTx[];
  constructor(scheme: Scheme, inputHistory: SingleInputTx[]) {
    super("Swap Contract / Unexpected closed State");
    this.scheme = scheme;
    this.inputHistory = inputHistory;
  }
}

export const getAvailableActions = (scheme: Scheme, state: ActiveState): Action[] => {
  switch (state.typeName) {
    case "WaitingSellerOffer":
      return [
        {
          typeName: "ProvisionOffer",
          owner: "seller",
          input: {
            input_from_party: scheme.offer.seller,
            that_deposits: scheme.offer.asset.amount,
            of_token: scheme.offer.asset.token,
            into_account: scheme.offer.seller,
          },
        },
      ];
    case "NoSellerOfferInTime":
      return [
        {
          typeName: "RetrieveMinimumLovelaceAdded",
          owner: "anybody",
        },
      ];
    case "WaitingForAnswer":
      return [
        {
          typeName: "Swap",
          owner: "buyer",
          input: {
            input_from_party: scheme.ask.buyer,
            that_deposits: scheme.ask.asset.amount,
            of_token: scheme.ask.asset.token,
            into_account: scheme.ask.buyer,
          },
        },
        {
          typeName: "Retract",
          owner: "seller",
          input: {
            for_choice_id: {
              choice_name: "retract",
              choice_owner: scheme.offer.seller,
            },
            input_that_chooses_num: 0n,
          },
        },
      ];
    case "WaitingForSwapConfirmation":
      return [
        {
          typeName: "ConfirmSwap",
          owner: "anybody",
          input: "input_notify",
        },
      ];
  }
};

export const getState = (scheme: Scheme, now: Timeout, inputHistory: SingleInputTx[], state?: MarloweState): State => {
  return state ? getActiveState(scheme, now, inputHistory, state) : getClosedState(scheme, inputHistory);
};

export const getClosedState = (scheme: Scheme, inputHistory: SingleInputTx[]): Closed => {
  switch (inputHistory.length) {
    // Offer Provision Deadline has passed and there is one reduced applied to close the contract
    case 0:
      return {
        typeName: "Closed",
        reason: { typeName: "NoOfferProvisionnedOnTime" },
      };
    case 1:
      return {
        typeName: "Closed",
        reason: { typeName: "NotAnsweredOnTime" },
      };
    case 2: {
      const isRetracted =
        G.IChoice.is(inputHistory[1].input) && inputHistory[1].input.for_choice_id.choice_name == "retract";
      const nbDeposits = inputHistory.filter((singleInputTx) => G.IDeposit.is(singleInputTx.input)).length;
      if (isRetracted && nbDeposits === 1) {
        return {
          typeName: "Closed",
          reason: { typeName: "SellerRetracted" },
        };
      }
      if (nbDeposits === 2) {
        return {
          typeName: "Closed",
          reason: { typeName: "SwappedButNotNotifiedOnTime" },
        };
      }
      break;
    }
    case 3: {
      const nbDeposits = inputHistory.filter((singleInputTx) => G.IDeposit.is(singleInputTx.input)).length;
      const nbNotify = inputHistory.filter((singleInputTx) => G.INotify.is(singleInputTx.input)).length;
      if (nbDeposits === 2 && nbNotify === 1) {
        return {
          typeName: "Closed",
          reason: { typeName: "Swapped" },
        };
      }
    }
  }
  throw new UnexpectedClosedSwapContractState(scheme, inputHistory);
};

export const getActiveState = (
  scheme: Scheme,
  now: Timeout,
  inputHistory: SingleInputTx[],
  state: MarloweState
): ActiveState => {
  switch (inputHistory.length) {
    case 0:
      return now < scheme.offer.deadline ? { typeName: "WaitingSellerOffer" } : { typeName: "NoSellerOfferInTime" };
    case 1:
      if (now < scheme.ask.deadline) {
        return { typeName: "WaitingForAnswer" };
      }
      break;
    case 2: {
      const nbDeposits = inputHistory.filter((singleInputTx) => G.IDeposit.is(singleInputTx.input)).length;
      if (nbDeposits === 2 && now < scheme.swapConfirmation.deadline) {
        return { typeName: "WaitingForSwapConfirmation" };
      }
      break;
    }
  }

  throw new UnexpectedActiveSwapContractState(scheme, inputHistory, state);
};

export function mkContract(scheme: Scheme): Contract {
  const mkOffer = (ask: Contract): Contract => {
    const depositOffer = {
      party: scheme.offer.seller,
      deposits: scheme.offer.asset.amount,
      of_token: scheme.offer.asset.token,
      into_account: scheme.offer.seller,
    };

    return {
      when: [{ case: depositOffer, then: ask }],
      timeout: scheme.offer.deadline,
      timeout_continuation: close,
    };
  };

  const mkAsk = (confirmSwap: Contract): Contract => {
    const depositAsk = {
      party: scheme.ask.buyer,
      deposits: scheme.ask.asset.amount,
      of_token: scheme.ask.asset.token,
      into_account: scheme.ask.buyer,
    };
    const chooseToRetract = {
      choose_between: [{ from: 0n, to: 0n }],
      for_choice: {
        choice_name: "retract",
        choice_owner: scheme.offer.seller,
      },
    };
    const payToParties = {
      pay: scheme.offer.asset.amount,
      token: scheme.offer.asset.token,
      from_account: scheme.offer.seller,
      to: { account: scheme.ask.buyer },
      then: {
        pay: scheme.ask.asset.amount,
        token: scheme.ask.asset.token,
        from_account: scheme.ask.buyer,
        to: { account: scheme.offer.seller },
        then: confirmSwap,
      },
    };
    return {
      when: [
        {
          case: depositAsk,
          then: payToParties,
        },
        {
          case: chooseToRetract,
          then: close,
        },
      ],
      timeout: scheme.ask.deadline,
      timeout_continuation: close,
    };
  };

  /*
   * The buyer has provided a deposit, the swapped is theoritically done, but to avoid double-satisfaction attack an
   * extra Notify input is added after the swap. This Notify can be done by anybody.
   *
   * Marlowe's prevention of double-satisfaction attacks requires that no external payments be made from a Marlowe contract
   * if another Plutus script runs in the transaction. Thus, if an open-role is distributed in a transaction, the transaction
   * cannot do Pay to parties or implicit payments upon Close. Typically, the distribution of an open-role in a Marlowe contract
   * will be followed by a Notify TrueObs case so that further execution of the contract does not proceed in that transactions.
   * External payments can be made in subsequent transactions.
   */
  const mkSwapConfirmation = (): Contract => {
    return {
      when: [{ case: { notify_if: true }, then: close }],
      timeout: scheme.swapConfirmation.deadline,
      timeout_continuation: close,
    };
  };

  return mkOffer(mkAsk(mkSwapConfirmation()));
}
